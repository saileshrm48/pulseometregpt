<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>PulseCam â€” Stable BPM + HRV (v2.4)</title>
  <meta name="theme-color" content="#0ea5e9" />
  <style>
    :root { --bg:#0b1220; --card:#0f172a; --muted:#94a3b8; --text:#e2e8f0; --accent:#22d3ee; --good:#34d399; --warn:#fbbf24; --bad:#f87171; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--text); }
    .wrap { max-width: 1080px; margin: 0 auto; padding: 16px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    h1 { margin: 6px 0 2px; font-size: 22px; }
    .sub { color: var(--muted); font-size: 13px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 980px) { .grid { grid-template-columns: 1.2fr 1fr; } }
    .card { background: linear-gradient(180deg, #0e172a, #0b1220); border:1px solid #1f2b47; border-radius: 16px; }
    .card > .hd { display:flex; align-items:center; justify-content:space-between; padding: 12px 14px; border-bottom: 1px solid #1f2b47; }
    .card > .bd { padding: 12px 14px; }
    .btn { border: 1px solid #1f2b47; background:#0b2033; color: var(--text); border-radius: 10px; padding:9px 14px; font-weight:700; cursor:pointer; }
    .btn[disabled]{ opacity:.55; cursor:not-allowed; }
    .pill { background:#0b2033; border:1px solid #1f2b47; border-radius:999px; padding:5px 8px; font-size:12px; color:var(--muted); margin-left:6px; }
    #bpm { font-size: 56px; font-weight: 800; margin: 10px 0 2px; }
    #qual { font-size: 13px; color: var(--muted); }
    video, canvas { display:block; width:100%; border-radius:12px; background:#000; }
    #preview { max-height: 220px; }
    #wave { height: 240px; border:1px solid #1f2b47; margin-top:10px; }
    .ok { color: var(--good); } .warn { color: var(--warn); } .bad { color: var(--bad); }
    .log { font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 12px; color: #9fb3c8; max-height: 140px; overflow:auto; background:#07101d; border:1px solid #1f2b47; border-radius:10px; padding:8px; }
    .hrvgrid { display:grid; grid-template-columns: repeat(2, 1fr); gap:10px; }
    @media (min-width: 720px){ .hrvgrid { grid-template-columns: repeat(3, 1fr); } }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>PulseCam <span class="pill">PPG v2.4</span></h1>
        <div class="sub">Green-ROI reflectance PPG Â· Stable BPM + HRV (RMSSD, SDNN, pNN50). HTTPS required.</div>
      </div>
      <div style="display:flex; gap:8px; flex-wrap:wrap;">
        <button id="startBtn" class="btn" type="button">â–¶ Start</button>
        <button id="stopBtn" class="btn" type="button" disabled>â–  Stop</button>
        <button id="torchBtn" class="btn" type="button" disabled>ðŸ’¡ Torch</button>
      </div>
    </header>

    <div class="grid" style="margin-top:12px;">
      <section class="card">
        <div class="hd">
          <strong>Signal</strong>
          <div>
            <span class="pill" id="fr">FPS: â€”</span>
            <span class="pill" id="torchState">Torch: â€”</span>
            <span class="pill" id="coverage">Coverage: â€”</span>
            <span class="pill" id="sat">Saturation: â€”</span>
            <span class="pill" id="sqi">SQI: â€”</span>
          </div>
        </div>
        <div class="bd">
          <video id="preview" playsinline muted></video>
          <canvas id="wave"></canvas>
          <div class="sub" style="margin-top:8px;">Tip: Fully cover the rear camera with your fingertip. Use gentle pressure and keep still.</div>
        </div>
      </section>

      <section class="card">
        <div class="hd">
          <strong>Heart</strong>
          <div>
            <span class="pill" id="quality">Quality: â€”</span>
            <span class="pill" id="conf">Confidence: â€”</span>
          </div>
        </div>
        <div class="bd">
          <div id="bpm">â€”</div>
          <div id="qual">Waiting for a stable signalâ€¦</div>
          <div class="log" id="log" style="margin-top:10px;"></div>
        </div>
      </section>
    </div>

    <!-- HRV Panel -->
    <section class="card" style="margin-top:12px;">
      <div class="hd">
        <strong>HRV (last 60s)</strong>
        <div>
          <span class="pill" id="hrvBeats">Beats: â€”</span>
          <span class="pill" id="hrvQual">HRV Quality: â€”</span>
        </div>
      </div>
      <div class="bd">
        <div class="hrvgrid">
          <div><div class="sub">Mean HR</div><div style="font-size:24px;font-weight:700" id="meanHR">â€”</div></div>
          <div><div class="sub">SDNN (ms)</div><div style="font-size:24px;font-weight:700" id="sdnn">â€”</div></div>
          <div><div class="sub">RMSSD (ms)</div><div style="font-size:24px;font-weight:700" id="rmssd">â€”</div></div>
          <div><div class="sub">pNN50 (%)</div><div style="font-size:24px;font-weight:700" id="pnn50">â€”</div></div>
          <div><div class="sub">IBIs used</div><div style="font-size:24px;font-weight:700" id="rrUsed">â€”</div></div>
          <div><div class="sub">Artifacts dropped</div><div style="font-size:24px;font-weight:700" id="rrDropped">â€”</div></div>
        </div>
        <div class="sub" style="margin-top:8px;">HRV needs a calm, steady signal. Aim for â‰¥60â€¯s of clean data.</div>
      </div>
    </section>
  </div>

  <!-- Hidden processing video element -->
  <video id="video" playsinline muted style="position:absolute; width:1px; height:1px; opacity:0; pointer-events:none;"></video>

<script>
  // ===== Logging =====
  function log(){ const el=document.getElementById('log'); if(!el) return; el.textContent = `[${new Date().toLocaleTimeString()}] ${Array.from(arguments).join(' ')}\n` + el.textContent; }
  window.addEventListener('error', (e)=>log('Runtime error:', e.message));
  window.addEventListener('unhandledrejection', (e)=>log('Promise rejection:', (e.reason && e.reason.message) || e.reason));

  // ===== State =====
  let stream, track, torchOn=false;
  let v, preview, ctx, cvs, drawCtx, drawCvs;
  let rafId=null, procId=null, estId=null;

  // Processing constants
  const RS = 30;                 // resample rate (Hz)
  const BUFFER_SECS = 18;        // raw ring capacity
  const MAX_RAW = RS * BUFFER_SECS * 4;

  // Raw rings (irregular time base)
  const times = new Float64Array(MAX_RAW);
  const samples = new Float32Array(MAX_RAW);
  let wr = 0, count = 0;

  // Uniform grid buffers (15 s)
  const UNIFORM_N = RS * 15;
  const uniT = new Float64Array(UNIFORM_N);
  const uniY = new Float32Array(UNIFORM_N);

  // Beat storage for HRV (rolling, absolute seconds from performance.now()/1000)
  const beatTimes = []; // seconds
  let lastAppendedBeatTime = 0;

  const bpmHist = []; const BPM_HIST_N = 9;
  let lastFrameTime = 0;

  // ===== UI helpers =====
  const setText = (id, t) => { const el = document.getElementById(id); if (el) el.textContent = t; };
  function setQuality(status, msg){
    const el = document.getElementById('quality');
    el.textContent = `Quality: ${status}`;
    el.classList.remove('ok','warn','bad');
    el.classList.add(status==='Good'?'ok':status==='Fair'?'warn':'bad');
    document.getElementById('qual').textContent = msg;
  }

  // ===== Metrics =====
  function coverageMetric(frame){ let redDominant=0; const step=4*8; for(let i=0;i<frame.data.length;i+=step){ const r=frame.data[i], g=frame.data[i+1], b=frame.data[i+2]; if(r>g*1.2 && r>b*1.2) redDominant++; } return redDominant/(frame.data.length/step); }
  function saturationMetric(frame){ let sat=0; const step=4*8; for(let i=0;i<frame.data.length;i+=step){ const r=frame.data[i]; if(r>250) sat++; } return sat/(frame.data.length/step); }

  // ===== DSP helpers =====
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  function detrendUniform(y, alpha){ let m = y[0]; for(let i=0;i<y.length;i++){ m = m + alpha*(y[i]-m); y[i] = y[i]-m; } }

  class Biquad{
    constructor(type, fs, f0, Q){ this.type=type; this.fs=fs; this.f0=f0; this.Q=Q; this.x1=this.x2=this.y1=this.y2=0; this.update(); }
    update(){ const fs=this.fs, f0=this.f0, Q=this.Q; const w0=2*Math.PI*f0/fs, alpha=Math.sin(w0)/(2*Q), cos=Math.cos(w0);
      let b0,b1,b2,a0,a1,a2;
      if(this.type==='lowpass'){ b0=(1-cos)/2; b1=1-cos; b2=(1-cos)/2; a0=1+alpha; a1=-2*cos; a2=1-alpha; }
      else if(this.type==='highpass'){ b0=(1+cos)/2; b1=-(1+cos); b2=(1+cos)/2; a0=1+alpha; a1=-2*cos; a2=1-alpha; }
      else { b0=Q*alpha; b1=0; b2=-Q*alpha; a0=1+alpha; a1=-2*cos; a2=1-alpha; }
      this.b0=b0/a0; this.b1=b1/a0; this.b2=b2/a0; this.a1=a1/a0; this.a2=a2/a0; }
    process(x){ const y=this.b0*x + this.b1*this.x1 + this.b2*this.x2 - this.a1*this.y1 - this.a2*this.y2; this.x2=this.x1; this.x1=x; this.y2=this.y1; this.y1=y; return y; }
    reset(){ this.x1=this.x2=this.y1=this.y2=0; }
  }

  // Filters: HP 0.6 Hz, LP 3.5 Hz (â‰ˆ 36â€“210 BPM)
  const hp = new Biquad('highpass', RS, 0.6, 0.707);
  const lp = new Biquad('lowpass',  RS, 3.5, 0.707);
  function bandlimitInPlace(){ hp.reset(); lp.reset(); for(let i=0;i<UNIFORM_N;i++){ uniY[i] = lp.process(hp.process(uniY[i])); } }

  function pushSample(t, x){ times[wr]=t; samples[wr]=x; wr=(wr+1)%MAX_RAW; count=Math.min(count+1, MAX_RAW); }

  function resampleUniform(){
    if (count < RS*4) return false;
    const now = performance.now()/1000, dt = 1/RS, start = now - (UNIFORM_N-1)*dt;
    for (let i=0;i<UNIFORM_N;i++) uniT[i] = start + i*dt;

    const n = count; const bufT=new Float64Array(n), bufY=new Float32Array(n);
    for (let i=0;i<n;i++){ const idx=(wr - n + i + MAX_RAW)%MAX_RAW; bufT[i]=times[idx]; bufY[i]=samples[idx]; }

    let j=1;
    for (let i=0;i<UNIFORM_N;i++){
      const t=uniT[i];
      while (j<n && bufT[j] < t) j++;
      if (j<=0){ uniY[i]=bufY[0]; continue; }
      if (j>=n){ uniY[i]=bufY[n-1]; continue; }
      const t1=bufT[j-1], t2=bufT[j], y1=bufY[j-1], y2=bufY[j], a=(t - t1)/Math.max(1e-6,(t2-t1));
      uniY[i] = y1 + a*(y2 - y1);
    }
    return true;
  }

  // ===== Estimators =====
  function autocorrEstimate(){
    const N = UNIFORM_N;
    let mean=0; for (let i=0;i<N;i++) mean += uniY[i]; mean/=N;
    let varr=0; for (let i=0;i<N;i++){ const d=uniY[i]-mean; uniY[i]=d; varr += d*d; }
    const norm = Math.sqrt(varr/N)+1e-6; for (let i=0;i<N;i++) uniY[i]/=norm;

    const minBPM=40, maxBPM=180;
    const minLag = Math.floor(RS*60/maxBPM);
    const maxLag = Math.floor(RS*60/minBPM);
    let bestLag=-1, bestVal=-1, second=0;

    const corr = (lag)=>{ let s=0; for(let i=lag;i<N;i++) s += uniY[i]*uniY[i-lag]; return s; };

    for (let lag=minLag; lag<=maxLag; lag++){
      const s = corr(lag);
      if (s>bestVal){ second=bestVal; bestVal=s; bestLag=lag; }
      else if (s>second){ second=s; }
    }
    if (bestLag<0) return { bpm:null, conf:0 };

    const L=bestLag, y1=corr(Math.max(minLag,L-1)), y2=bestVal, y3=corr(Math.min(maxLag,L+1));
    const denom=(y1 - 2*y2 + y3); const delta=denom!==0 ? 0.5*(y1 - y3)/denom : 0;
    const refinedLag = clamp(L + delta, minLag, maxLag);
    const bpm = 60 * RS / refinedLag;
    const confAC = clamp((bestVal - second) / Math.max(1e-6, 1 - second), 0, 1);
    return { bpm, conf: confAC };
  }

  function peakDetect(){
    const N = UNIFORM_N; if (N < RS*5) return null;
    // dynamic threshold via RMS
    let rms=0; for(let i=0;i<N;i++) rms += uniY[i]*uniY[i]; rms = Math.sqrt(rms/N);
    const thr = 0.3 * rms;

    const peaks=[], refractory = Math.floor(0.25*RS); // 250 ms
    let last = -refractory;
    for(let i=1;i<N-1;i++){
      if (i-last < refractory) continue;
      if (uniY[i] > thr && uniY[i] > uniY[i-1] && uniY[i] > uniY[i+1]){
        peaks.push(uniT[i]); last=i;
      }
    }
    if (peaks.length < 2) return { bpm:null, conf:0, peaks:[] };

    const intervals = []; for (let i=1;i<peaks.length;i++) intervals.push(peaks[i]-peaks[i-1]);
    const avg = intervals.reduce((a,b)=>a+b,0)/intervals.length;
    const sd  = Math.sqrt(intervals.reduce((a,b)=>a + (b-avg)*(b-avg),0)/Math.max(1, intervals.length-1));
    const cv  = sd / Math.max(1e-6, avg);
    const bpm = 60/avg;
    const conf = clamp(1 - cv, 0, 1);
    return { bpm, conf, peaks };
  }

  // ===== HRV utils =====
  function computeHRVFromBeats(now){
    // Keep only last 120 s in memory; compute HRV on last 60 s
    while (beatTimes.length && beatTimes[0] < now - 120) beatTimes.shift();

    const windowStart = now - 60;
    const beats = beatTimes.filter(t => t >= windowStart);
    setText('hrvBeats', 'Beats: ' + beats.length);

    if (beats.length < 5){ // need enough for RR stats
      setText('hrvQual','HRV Quality: Low');
      setText('meanHR','â€”'); setText('sdnn','â€”'); setText('rmssd','â€”'); setText('pnn50','â€”');
      setText('rrUsed','0'); setText('rrDropped','0');
      return;
    }

    // RR intervals (ms)
    const rr = [];
    for (let i=1;i<beats.length;i++){
      rr.push((beats[i]-beats[i-1]) * 1000);
    }

    // Artifact handling
    const rrRangeFiltered = rr.filter(x => x>=300 && x<=2000);
    const med = median(rrRangeFiltered);
    const rrClean = rrRangeFiltered.filter(x => Math.abs(x - med) <= 0.20 * med); // Â±20% of median
    const dropped = rr.length - rrClean.length;

    if (rrClean.length < 3){
      setText('hrvQual','HRV Quality: Low');
      setText('meanHR','â€”'); setText('sdnn','â€”'); setText('rmssd','â€”'); setText('pnn50','â€”');
      setText('rrUsed', rrClean.length.toString()); setText('rrDropped', dropped.toString());
      return;
    }

    const meanRR = mean(rrClean);
    const sdnn = std(rrClean);
    const rmssd = Math.sqrt(mean(successiveDiffs(rrClean).map(x => x*x)));
    const pnn50 = 100 * (successiveDiffs(rrClean).filter(x => Math.abs(x) > 50).length / Math.max(1, rrClean.length-1));

    const meanHR = 60000 / meanRR;

    setText('meanHR', Math.round(meanHR) + ' bpm');
    setText('sdnn',  Math.round(sdnn).toString());
    setText('rmssd', Math.round(rmssd).toString());
    setText('pnn50', pnn50.toFixed(1));
    setText('rrUsed', rrClean.length.toString());
    setText('rrDropped', dropped.toString());

    // Simple quality flag
    const quality = (rmssd>5 && sdnn>5 && rrClean.length>=15) ? 'OK' : 'Low';
    setText('hrvQual', 'HRV Quality: ' + quality);
  }
  const mean = arr => arr.reduce((a,b)=>a+b,0)/arr.length;
  const median = arr => { if(!arr.length) return 0; const s=[...arr].sort((a,b)=>a-b); const m=Math.floor(s.length/2); return s.length%2?s[m] : (s[m-1]+s[m])/2; };
  const std = arr => { const m=mean(arr); let v=0; for(const x of arr) v+=(x-m)*(x-m); return Math.sqrt(v/Math.max(1,arr.length-1)); };
  const successiveDiffs = arr => arr.slice(1).map((x,i)=>x - arr[i]);

  // ===== Frame processing =====
  function processFrame(){
    if (!v.videoWidth) return;
    ctx.drawImage(v,0,0,cvs.width,cvs.height);
    const frame = ctx.getImageData(0,0,cvs.width,cvs.height);

    const cov = coverageMetric(frame); setText('coverage', `Coverage: ${(cov*100|0)}%`);
    const sat = saturationMetric(frame); setText('sat', `Saturation: ${(sat*100|0)}%`);

    // Center ROI â€” use GREEN channel mean intensity
    const W=cvs.width, H=cvs.height; const rx=Math.floor(W*0.25), ry=Math.floor(H*0.25), rw=Math.floor(W*0.5), rh=Math.floor(H*0.5);
    let sum=0, sum2=0, n=0;
    for (let y=ry;y<ry+rh;y++){
      for (let x=rx;x<rx+rw;x++){
        const i=(y*W + x)*4; const g=frame.data[i+1]; sum+=g; sum2+=g*g; n++;
      }
    }
    const meanG = sum/n; const stdG = Math.sqrt(Math.max(0, sum2/n - (meanG*meanG)));

    // Raw sample: mean green intensity
    const raw = meanG;

    const now = performance.now()/1000;
    pushSample(now, raw);

    // FPS
    const dt = now - (lastFrameTime || now); lastFrameTime = now;
    const fps = 1/Math.max(dt, 1/120); setText('fr', 'FPS: ' + fps.toFixed(0));

    // Quality hints
    const sqi = computeSQI(meanG, stdG, cov, sat); setText('sqi', 'SQI: ' + Math.round(sqi*100) + '%');
    if (cov < 0.25) setQuality('Poor','Cover the camera fully with your fingertip.');
    else if (sat > 0.25) setQuality('Fair','Too bright; ease pressure or adjust finger.');
    else if (fps < 20) setQuality('Fair','Low frame rate. Keep device cool/close apps.');
    else if (sqi < 0.35) setQuality('Fair','Hold steady and relax your finger.');
    else setQuality('Good','Hold steady. Breathe normally.');
  }

  function computeSQI(frameMean, frameStd, coverage, sat){
    const acdc = clamp((frameStd/Math.max(1e-3, frameMean)) * 5, 0, 1);
    const covf = clamp((coverage - 0.2)/0.6, 0, 1);
    const satf = 1 - clamp((sat - 0.05)/0.3, 0, 1);
    return clamp(0.2*acdc + 0.5*covf + 0.3*satf, 0, 1);
  }

  // ===== BPM + HRV estimation each second =====
  function estimateBPM(){
    if (!resampleUniform()) return;

    detrendUniform(uniY, 1 - Math.exp(-2*Math.PI*0.5 / RS)); // ~0.5 Hz HP for drift
    bandlimitInPlace();

    const ac = autocorrEstimate();
    const pk = peakDetect();

    // Append new beats for HRV
    if (pk && pk.peaks && pk.peaks.length){
      for (const t of pk.peaks){
        if (t > lastAppendedBeatTime){ beatTimes.push(t); lastAppendedBeatTime = t; }
      }
    }

    // Fuse estimates for BPM
    let bpm=null, conf=0;
    if (ac.bpm && pk && pk.bpm){
      bpm = 0.6*ac.bpm + 0.4*pk.bpm;
      conf = clamp(0.6*ac.conf + 0.4*pk.conf, 0, 1);
    } else if (ac.bpm){ bpm = ac.bpm; conf = ac.conf; }
    else if (pk && pk.bpm){ bpm = pk.bpm; conf = pk.conf; }

    if (!bpm){
      document.getElementById('bpm').textContent = 'â€”';
      setText('conf', 'Confidence: 0%');
      computeHRVFromBeats(performance.now()/1000);
      return;
    }

    // Smoothing with clamp
    bpmHist.push(bpm); if (bpmHist.length > BPM_HIST_N) bpmHist.shift();
    const alpha = 0.10;
    const prev = estimateBPM.smooth ?? bpm;
    const proposal = prev*(1-alpha) + bpm*alpha;
    const maxDelta = 5;
    const clamped = clamp(proposal, prev - maxDelta, prev + maxDelta);
    estimateBPM.smooth = clamped;

    const finalBPM = Math.round(clamped);
    const bounded = finalBPM>=40 && finalBPM<=180;
    const confAdj = bounded ? conf : 0;

    setText('conf', `Confidence: ${(confAdj*100|0)}%`);

    if (!bounded || confAdj < 0.2){
      document.getElementById('bpm').textContent = 'â€”';
      setQuality('Poor','Unstable signal; adjust finger/lighting.');
    } else {
      document.getElementById('bpm').textContent = finalBPM;
    }

    // HRV compute/update
    computeHRVFromBeats(performance.now()/1000);
  }

  // ===== Drawing =====
  function draw(){
    const W=drawCvs.width, H=drawCvs.height; const ctx=drawCtx;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='#081325'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='#1f2b47'; ctx.lineWidth=1; ctx.beginPath();
    for (let x=0;x<W;x+=Math.floor(W/12)){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for (let y=0;y<H;y+=Math.floor(H/6)){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke();

    ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle='#7dd3fc';
    const N=UNIFORM_N;
    if (N>2 && uniT[0]!==0){
      const t0=uniT[0], totalSec=(N/RS);
      for (let i=0;i<N;i++){
        const x=(uniT[i]-t0)/totalSec;
        const y=uniY[i];
        const px=x*W; const py=H*0.5 - y*(H*0.35);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
    }
    rafId = requestAnimationFrame(draw);
  }

  // ===== Camera / App lifecycle =====
  async function start(){
    if (stream) return;
    try{
      const constraints = {
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 320, max: 640 },
          height:{ ideal: 240, max: 480 },
          frameRate: { min: 24, ideal: 60, max: 120 }
        },
        audio: false
      };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      v.srcObject = stream; preview.srcObject = stream;
      track = stream.getVideoTracks()[0];
      await v.play(); await preview.play();

      // Torch availability (Android Chrome most likely)
      if (track.getCapabilities && track.getCapabilities().torch){
        document.getElementById('torchBtn').disabled = false;
        setText('torchState', 'Torch: available');
        try{ await track.applyConstraints({ advanced:[{ torch:true }] }); torchOn=true; setText('torchState','Torch: on'); }catch(e){ log('Torch enable failed:', e.message); }
      } else {
        setText('torchState', 'Torch: not available');
      }

      initCanvas(); runProcessing();
      document.getElementById('startBtn').disabled = true;
      document.getElementById('stopBtn').disabled  = false;
    } catch(err){
      log('Camera error:', err.message);
      alert('Could not access the camera. Please allow camera permissions and use HTTPS (or localhost).');
    }
  }

  function stop(){
    if (rafId) cancelAnimationFrame(rafId); rafId=null;
    if (procId) cancelAnimationFrame(procId); procId=null;
    if (estId) clearInterval(estId); estId=null;
    if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    document.getElementById('startBtn').disabled=false;
    document.getElementById('stopBtn').disabled=true;
    document.getElementById('torchBtn').disabled=true;
    setText('fr','FPS: â€”'); setText('coverage','Coverage: â€”'); setText('torchState','Torch: â€”'); setText('sat','Saturation: â€”'); setText('sqi','SQI: â€”');
    document.getElementById('bpm').textContent='â€”';
    setText('hrvBeats','Beats: â€”'); setText('hrvQual','HRV Quality: â€”');
    setText('meanHR','â€”'); setText('sdnn','â€”'); setText('rmssd','â€”'); setText('pnn50','â€”'); setText('rrUsed','â€”'); setText('rrDropped','â€”');
    setQuality('Poor','Stopped. Tap Start to measure again.');
    beatTimes.length = 0; lastAppendedBeatTime = 0;
  }

  async function toggleTorch(){
    if (!track || !track.applyConstraints) return;
    try{
      torchOn = !torchOn;
      await track.applyConstraints({ advanced:[{ torch: torchOn }] });
      setText('torchState', 'Torch: ' + (torchOn?'on':'off'));
    } catch(e){ log('Torch toggle failed:', e.message); }
  }

  function initCanvas(){
    drawCvs = document.getElementById('wave'); drawCtx = drawCvs.getContext('2d');
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const rect = drawCvs.getBoundingClientRect();
    drawCvs.width  = Math.floor(rect.width * dpr);
    drawCvs.height = Math.floor(rect.height * dpr);

    // Processing canvas (downsampled)
    cvs = document.createElement('canvas'); ctx = cvs.getContext('2d', { willReadFrequently: true });
    cvs.width = 160; cvs.height = 120;
  }

  function runProcessing(){
    const loop = () => { processFrame(); procId = requestAnimationFrame(loop); };
    loop();
    draw();
    estId = setInterval(estimateBPM, 1000);
  }

  // ===== DOM ready =====
  window.addEventListener('DOMContentLoaded', () => {
    v = document.getElementById('video');
    preview = document.getElementById('preview');
    document.getElementById('startBtn').addEventListener('click', start);
    document.getElementById('stopBtn').addEventListener('click', stop, { passive: true });
    document.getElementById('torchBtn').addEventListener('click', toggleTorch, { passive: true });
    setQuality('Poor','Tap Start, then place your fingertip gently over the rear camera.');
  });
</script>
</body>
</html>
