<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>PulseCam â€” Stable BPM via Phone Camera (v2.3)</title>
  <meta name="theme-color" content="#0ea5e9" />
  <style>
    :root { --bg:#0b1220; --card:#0f172a; --muted:#94a3b8; --text:#e2e8f0; --accent:#22d3ee; --good:#34d399; --warn:#fbbf24; --bad:#f87171; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--text); }
    .wrap { max-width: 1080px; margin: 0 auto; padding: 16px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    h1 { margin: 6px 0 2px; font-size: 22px; }
    .sub { color: var(--muted); font-size: 13px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 980px) { .grid { grid-template-columns: 1.2fr 1fr; } }
    .card { background: linear-gradient(180deg, #0e172a, #0b1220); border:1px solid #1f2b47; border-radius: 16px; }
    .card > .hd { display:flex; align-items:center; justify-content:space-between; padding: 12px 14px; border-bottom: 1px solid #1f2b47; }
    .card > .bd { padding: 12px 14px; }
    .btn { border: 1px solid #1f2b47; background:#0b2033; color: var(--text); border-radius: 10px; padding:9px 14px; font-weight:700; cursor:pointer; }
    .btn[disabled]{ opacity:.55; cursor:not-allowed; }
    .pill { background:#0b2033; border:1px solid #1f2b47; border-radius:999px; padding:5px 8px; font-size:12px; color:var(--muted); margin-left:6px; }
    #bpm { font-size: 56px; font-weight: 800; margin: 10px 0 2px; }
    #qual { font-size: 13px; color: var(--muted); }
    video, canvas { display:block; width:100%; border-radius:12px; background:#000; }
    #preview { max-height: 220px; }
    #wave { height: 240px; border:1px solid #1f2b47; margin-top:10px; }
    .ok { color: var(--good); } .warn { color: var(--warn); } .bad { color: var(--bad); }
    .log { font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 12px; color: #9fb3c8; max-height: 140px; overflow:auto; background:#07101d; border:1px solid #1f2b47; border-radius:10px; padding:8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>PulseCam <span class="pill">PPG v2.3</span></h1>
        <div class="sub">Stabilized BPM with proper resampling, green-ROI, SQI, gating, and outlier rejection. HTTPS required.</div>
      </div>
      <div style="display:flex; gap:8px; flex-wrap:wrap;">
        <button id="startBtn" class="btn" type="button">â–¶ Start</button>
        <button id="stopBtn" class="btn" type="button" disabled>â–  Stop</button>
        <button id="torchBtn" class="btn" type="button" disabled>ðŸ’¡ Torch</button>
      </div>
    </header>

    <div class="grid" style="margin-top:12px;">
      <section class="card">
        <div class="hd">
          <strong>Signal</strong>
          <div>
            <span class="pill" id="fr">FPS: â€”</span>
            <span class="pill" id="torchState">Torch: â€”</span>
            <span class="pill" id="coverage">Coverage: â€”</span>
            <span class="pill" id="sat">Saturation: â€”</span>
            <span class="pill" id="sqi">SQI: â€”</span>
          </div>
        </div>
        <div class="bd">
          <video id="preview" playsinline muted></video>
          <canvas id="wave"></canvas>
          <div class="sub" style="margin-top:8px;">Tip: Fully cover the rear camera with your fingertip. Use gentle pressure and keep still.</div>
        </div>
      </section>

      <section class="card">
        <div class="hd">
          <strong>Heart Rate</strong>
          <div>
            <span class="pill" id="quality">Quality: â€”</span>
            <span class="pill" id="conf">Confidence: â€”</span>
          </div>
        </div>
        <div class="bd">
          <div id="bpm">â€”</div>
          <div id="qual">Waiting for a stable signalâ€¦</div>
          <div class="log" id="log" style="margin-top:10px;"></div>
        </div>
      </section>
    </div>
  </div>

  <video id="video" playsinline muted style="position:absolute; width:1px; height:1px; opacity:0; pointer-events:none;"></video>

<script>
  // ===== Logging =====
  function log() {
    const el = document.getElementById('log');
    if (!el) return;
    el.textContent = `[${new Date().toLocaleTimeString()}] ${Array.from(arguments).join(' ')}\n` + el.textContent;
  }
  window.addEventListener('error', (e)=>log('Runtime error:', e.message));
  window.addEventListener('unhandledrejection', (e)=>log('Promise rejection:', (e.reason && e.reason.message) || e.reason));

  // ===== State =====
  let stream, track, torchAvailable=false, torchOn=false;
  let v, preview, ctx, cvs, drawCtx, drawCvs;
  let rafId=null, procId=null, estId=null;

  // Target sample rate (uniform grid for DSP)
  const RS = 30; // Hz
  const BUFFER_SECS = 12; // seconds stored
  const MAX_RAW = RS * BUFFER_SECS * 4; // allow oversampling in raw ring

  // Raw rings (irregular time base)
  const times = new Float64Array(MAX_RAW);
  const samples = new Float32Array(MAX_RAW);
  let wr = 0, count = 0;

  // Uniform grid buffers
  const UNIFORM_N = RS * 10; // last 10 s for estimation
  const uniT = new Float64Array(UNIFORM_N);
  const uniY = new Float32Array(UNIFORM_N);

  const bpmHist = []; const BPM_HIST_N = 7; // smoothing window
  let lastFrameTime = 0;

  // ===== UI helpers =====
  const setText = (id, t) => { const el = document.getElementById(id); if (el) el.textContent = t; };
  function setQuality(status, msg){
    const el = document.getElementById('quality');
    el.textContent = `Quality: ${status}`;
    el.classList.remove('ok','warn','bad');
    el.classList.add(status==='Good'?'ok':status==='Fair'?'warn':'bad');
    document.getElementById('qual').textContent = msg;
  }

  // ===== Metrics / SQI =====
  function computeSQI(frameMean, frameStd, coverage, sat){
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const acdc = clamp((frameStd/Math.max(1e-3, frameMean)) * 5, 0, 1); // scale
    const covf = clamp((coverage - 0.2)/0.6, 0, 1);
    const satf = 1 - clamp((sat - 0.05)/0.3, 0, 1);
    return clamp(0.2*acdc + 0.5*covf + 0.3*satf, 0, 1);
  }

  function roiCoverageAndSaturation(frame, W, H, rx, ry, rw, rh) {
    // Coverage: % pixels where GREEN is dominant (finger present) in ROI
    let cover = 0, sat = 0, n = 0;
    for (let y = ry; y < ry + rh; y++) {
      for (let x = rx; x < rx + rw; x++) {
        const i = (y * W + x) * 4;
        const r = frame.data[i], g = frame.data[i + 1], b = frame.data[i + 2];
        if (g > r * 1.1 && g > b * 1.1) cover++;
        if (g >= 245) sat++;
        n++;
      }
    }
    return { coverage: n ? cover / n : 0, saturation: n ? sat / n : 0 };
  }

  // ===== DSP helpers =====
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  // Simple highpass (detrend) on uniform grid: y[n] = x[n] - EMA(x)
  function detrendUniform(y, alpha){
    let m = y[0];
    for (let i=0;i<y.length;i++){
      m = m + alpha*(y[i] - m);
      y[i] = y[i] - m;
    }
  }

  // 2nd-order biquad â€” fs=RS
  class Biquad {
    constructor(type, fs, f0, Q){ this.type=type; this.fs=fs; this.set(f0,Q); this.x1=this.x2=this.y1=this.y2=0; }
    set(f0,Q){
      const fs=this.fs, w0=2*Math.PI*f0/fs, alpha=Math.sin(w0)/(2*Q), cos=Math.cos(w0);
      let b0,b1,b2,a0,a1,a2;
      if (this.type==='bandpass'){ b0=Q*alpha; b1=0; b2=-Q*alpha; a0=1+alpha; a1=-2*cos; a2=1-alpha; }
      else if (this.type==='lowpass'){ b0=(1-cos)/2; b1=1-cos; b2=(1-cos)/2; a0=1+alpha; a1=-2*cos; a2=1-alpha; }
      else if (this.type==='highpass'){ b0=(1+cos)/2; b1=-(1+cos); b2=(1+cos)/2; a0=1+alpha; a1=-2*cos; a2=1-alpha; }
      this.b0=b0/a0; this.b1=b1/a0; this.b2=b2/a0; this.a1=a1/a0; this.a2=a2/a0;
    }
    process(x){ const y=this.b0*x + this.b1*this.x1 + this.b2*this.x2 - this.a1*this.y1 - this.a2*this.y2; this.x2=this.x1; this.x1=x; this.y2=this.y1; this.y1=y; return y; }
    reset(){ this.x1=this.x2=this.y1=this.y2=0; }
  }

  // Proper 0.5â€“3.0 Hz band (â‰ˆ30â€“180 BPM)
  const hp = new Biquad('highpass', RS, 0.5, 0.707);
  const lp = new Biquad('lowpass',  RS, 3.0, 0.707);

  function bandpassInPlace(){
    hp.reset(); lp.reset();
    const N = UNIFORM_N;
    for (let i=0;i<N;i++){ uniY[i] = lp.process(hp.process(uniY[i])); }
  }

  function pushSample(t, x){ times[wr]=t; samples[wr]=x; wr=(wr+1)%MAX_RAW; count=Math.min(count+1, MAX_RAW); }

  // Linear resample from irregular (times,samples) into last 10s on uniform grid (uniT,uniY)
  function resampleUniform(){
    if (count < RS*3) return false; // need â‰¥3 s
    const now = performance.now()/1000;
    const dt = 1/RS;
    const start = now - (UNIFORM_N-1)*dt;
    for (let i=0;i<UNIFORM_N;i++){ uniT[i] = start + i*dt; }

    // Copy ring into linear (oldest->newest)
    const n = count; const bufT = new Float64Array(n); const bufY = new Float32Array(n);
    for (let i=0;i<n;i++){ const idx=(wr - n + i + MAX_RAW)%MAX_RAW; bufT[i]=times[idx]; bufY[i]=samples[idx]; }

    // Interpolate
    let j=1;
    for (let i=0;i<UNIFORM_N;i++){
      const t = uniT[i];
      while (j < n && bufT[j] < t) j++;
      if (j<=0){ uniY[i] = bufY[0]; continue; }
      if (j>=n){ uniY[i] = bufY[n-1]; continue; }
      const t1 = bufT[j-1], t2 = bufT[j];
      const y1 = bufY[j-1], y2 = bufY[j];
      const a = (t - t1)/Math.max(1e-6, (t2 - t1));
      uniY[i] = y1 + a*(y2 - y1);
    }
    return true;
  }

  function autocorrPeak(){
    // Normalize
    const N = UNIFORM_N;
    let mean=0; for (let i=0;i<N;i++) mean += uniY[i]; mean/=N;
    let varr=0; for (let i=0;i<N;i++){ const d=uniY[i]-mean; uniY[i]=d; varr += d*d; }
    const norm = Math.sqrt(varr/N)+1e-6; for (let i=0;i<N;i++) uniY[i]/=norm;

    // Lag search 40â€“180 BPM
    const minBPM=40, maxBPM=180;
    const minLag = Math.floor(RS*60/maxBPM);
    const maxLag = Math.floor(RS*60/minBPM);
    let bestLag=-1, bestVal=-1, second=0;

    for (let lag=minLag; lag<=maxLag; lag++){
      let s=0; for (let i=lag;i<N;i++) s += uniY[i]*uniY[i-lag];
      if (s>bestVal){ second=bestVal; bestVal=s; bestLag=lag; }
      else if (s>second){ second=s; }
    }
    if (bestLag<0) return { bpm:null, conf:0 };

    // Parabolic refine
    const corr = (lag)=>{ let s=0; for (let i=lag;i<N;i++) s += uniY[i]*uniY[i-lag]; return s; };
    const L=bestLag, y1=corr(Math.max(minLag,L-1)), y2=bestVal, y3=corr(Math.min(maxLag,L+1));
    const denom = (y1 - 2*y2 + y3); const delta = denom!==0 ? 0.5*(y1 - y3)/denom : 0;
    const refinedLag = clamp(L + delta, minLag, maxLag);

    const bpm = 60 * RS / refinedLag;
    const conf = clamp((bestVal - second) / Math.max(1e-6, 1 - second), 0, 1);
    return { bpm, conf };
  }

  // ===== Frame processing =====
  function processFrame(){
    if (!v.videoWidth) return;
    ctx.drawImage(v,0,0,cvs.width,cvs.height);
    const frame = ctx.getImageData(0,0,cvs.width,cvs.height);

    // ROI (center) and GREEN-channel stats
    const W=cvs.width, H=cvs.height;
    const rx=Math.floor(W*0.25), ry=Math.floor(H*0.25), rw=Math.floor(W*0.5), rh=Math.floor(H*0.5);

    let sum=0, sum2=0, n=0;
    for (let y=ry;y<ry+rh;y++){
      for (let x=rx;x<rx+rw;x++){
        const i=(y*W + x)*4; const g=frame.data[i+1];
        sum+=g; sum2+=g*g; n++;
      }
    }
    const mean = n ? sum/n : 0;
    const std = n ? Math.sqrt(Math.max(0, sum2/n - mean*mean)) : 0;

    // ROI-consistent coverage & saturation (GREEN dominance / clip)
    const { coverage: cov, saturation: sat } = roiCoverageAndSaturation(frame, W, H, rx, ry, rw, rh);
    setText('coverage', `Coverage: ${(cov*100|0)}%`);
    setText('sat',       `Saturation: ${(sat*100|0)}%`);

    // Illumination-invariant PPG proxy: spatial MEAN of GREEN (negated optional)
    const raw = -mean;

    // Push with timestamp
    const now = performance.now()/1000;
    pushSample(now, raw);

    // FPS (instantaneous)
    const dt = now - (lastFrameTime || now); lastFrameTime = now;
    const fps = 1/Math.max(dt, 1/120); setText('fr', 'FPS: ' + fps.toFixed(0));

    // Quality hints & SQI
    const sqi = computeSQI(mean, std, cov, sat); setText('sqi', 'SQI: ' + Math.round(sqi*100) + '%');
    if (cov < 0.25) setQuality('Poor','Cover the camera fully with your fingertip.');
    else if (sat > 0.35) setQuality('Fair','Too bright; ease pressure or adjust finger.');
    else if (fps < 20) setQuality('Fair','Low frame rate. Keep device cool/close apps.');
    else if (sqi < 0.35) setQuality('Fair','Hold steady and relax your finger.');
    else setQuality('Good','Hold steady. Breathe normally.');

    // Gate: only allow estimation when basic conditions are good
    processFrame.good = (cov >= 0.30) && (sat <= 0.35) && (sqi >= 0.35) && (fps >= 20);
  }

  // ===== BPM estimation on a 1 s cadence =====
  function estimateBPM(){
    if (!processFrame.good){
      document.getElementById('bpm').textContent = 'â€”';
      setText('conf', 'Confidence: 0%');
      return;
    }
    if (!resampleUniform()) return;

    // Detrend + bandpass in place (0.5â€“3.0 Hz ~ 30â€“180 BPM)
    detrendUniform(uniY, 1 - Math.exp(-2*Math.PI*0.5 / RS));
    bandpassInPlace();

    const { bpm, conf } = autocorrPeak();
    if (!bpm){
      document.getElementById('bpm').textContent = 'â€”';
      setText('conf', 'Confidence: 0%');
      return;
    }

    // Outlier rejection vs rolling median (tighter guard)
    bpmHist.push(bpm); if (bpmHist.length > BPM_HIST_N) bpmHist.shift();
    const sorted=[...bpmHist].sort((a,b)=>a-b);
    const median = sorted[Math.floor(sorted.length/2)];
    const isOutlier = Math.abs(bpm - median) > 12;

    // Confidence-weighted smoothing (faster when confidence high)
    const alpha = clamp(0.1 + 0.5 * conf, 0.15, 0.55);
    estimateBPM.smooth = (estimateBPM.smooth ?? bpm)*(1-alpha) + (isOutlier?median:bpm)*alpha;
    const finalBPM = Math.round(estimateBPM.smooth);

    const bounded = finalBPM>=40 && finalBPM<=180;
    const confAdj = bounded ? conf : 0;
    setText('conf', `Confidence: ${(confAdj*100|0)}%`);

    if (!bounded || confAdj < 0.2){
      document.getElementById('bpm').textContent = 'â€”';
      setQuality('Poor','Unstable signal; adjust finger/lighting.');
      return;
    }
    document.getElementById('bpm').textContent = finalBPM;
  }

  // ===== Drawing =====
  function draw(){
    const W=drawCvs.width, H=drawCvs.height; const ctx=drawCtx;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='#081325'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='#1f2b47'; ctx.lineWidth=1; ctx.beginPath();
    for (let x=0;x<W;x+=Math.floor(W/12)){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for (let y=0;y<H;y+=Math.floor(H/6)){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke();

    ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle='#7dd3fc';
    const N=UNIFORM_N; if (N>2 && uniT[0]!==0){
      const t0=uniT[0];
      for (let i=0;i<N;i++){
        const x=(uniT[i]-t0)/(10); const y=uniY[i];
        const px=x*W; const py=H*0.5 - y*(H*0.35);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
    }
    rafId = requestAnimationFrame(draw);
  }

  // ===== Camera / App lifecycle =====
  async function start(){
    if (stream) return;
    try{
      // Constrain to small resolution & higher frameRate to reduce exposure hunting
      const constraints = {
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 320, max: 640 },
          height:{ ideal: 240, max: 480 },
          frameRate: { min: 24, ideal: 60, max: 120 }
        }
      };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      v.srcObject = stream; preview.srcObject = stream;
      track = stream.getVideoTracks()[0];
      await v.play(); await preview.play();

      // Torch availability
      if (track.getCapabilities && track.getCapabilities().torch){
        torchAvailable = true;
        document.getElementById('torchBtn').disabled = false;
        setText('torchState', 'Torch: available');
        try{
          await track.applyConstraints({ advanced:[{ torch:true }] });
          torchOn=true; setText('torchState','Torch: on');
        }catch(e){ log('Torch enable failed:', e.message); }
      } else {
        setText('torchState', 'Torch: not available');
      }

      initCanvas(); runProcessing();

      document.getElementById('startBtn').disabled = true;
      document.getElementById('stopBtn').disabled  = false;
    } catch(err){
      log('Camera error:', err.message);
      alert('Could not access the camera. Please allow camera permissions and use HTTPS (or localhost).');
    }
  }

  function stop(){
    if (rafId) cancelAnimationFrame(rafId); rafId=null;
    if (procId) cancelAnimationFrame(procId); procId=null;
    if (estId) clearInterval(estId); estId=null;
    if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    document.getElementById('startBtn').disabled=false;
    document.getElementById('stopBtn').disabled=true;
    document.getElementById('torchBtn').disabled=true;
    setText('fr','FPS: â€”'); setText('coverage','Coverage: â€”'); setText('torchState','Torch: â€”'); setText('sat','Saturation: â€”'); setText('sqi','SQI: â€”');
    document.getElementById('bpm').textContent='â€”';
    setQuality('Poor','Stopped. Tap Start to measure again.');
  }

  async function toggleTorch(){
    if (!track || !track.applyConstraints) return;
    try{
      torchOn = !torchOn;
      await track.applyConstraints({ advanced:[{ torch: torchOn }] });
      setText('torchState', 'Torch: ' + (torchOn?'on':'off'));
    } catch(e){ log('Torch toggle failed:', e.message); }
  }

  function initCanvas(){
    drawCvs = document.getElementById('wave'); drawCtx = drawCvs.getContext('2d');
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const rect = drawCvs.getBoundingClientRect();
    drawCvs.width  = Math.floor(rect.width * dpr);
    drawCvs.height = Math.floor(rect.height * dpr);

    // Processing canvas (downsampled)
    cvs = document.createElement('canvas'); ctx = cvs.getContext('2d', { willReadFrequently: true });
    cvs.width = 160; cvs.height = 120;
  }

  function runProcessing(){
    const loop = () => { processFrame(); procId = requestAnimationFrame(loop); };
    loop();
    draw();
    estId = setInterval(estimateBPM, 1000);
  }

  // ===== DOM ready =====
  window.addEventListener('DOMContentLoaded', () => {
    v = document.getElementById('video');
    preview = document.getElementById('preview');
    document.getElementById('startBtn').addEventListener('click', start);
    document.getElementById('stopBtn').addEventListener('click', stop, { passive: true });
    document.getElementById('torchBtn').addEventListener('click', toggleTorch, { passive: true });
    setQuality('Poor','Tap Start, then place your fingertip gently over the rear camera.');
  });
</script>
</body>
</html>
